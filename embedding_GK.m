function W = embedding_GK(PC_cent_K_Z_em,PC_X_std,k_neig)
%Embed two sets of centered data cloud
%Input:
%PC_cent_K_Z_em:    PCA scores for centered Gaussian kernel generated by
%   embeding variation sources, Z_em, which is different from true and
%   unknown variation sources.
%PC_X_std:          PCA scores for centered observational data
%k_neig:            Number of neighbors in estimating the embedding
%Output:            
%W:                 Weight matrix for data embedding for estimating
%                   variation sources.

[N,P] = size(PC_cent_K_Z_em);
%Align variance for each coordinates between PC_cent_K_Z_em and PC_X_std
for p = 1:P
    PC_X_std(:,p) = PC_X_std(:,p)/std(PC_X_std(:,p))*std(PC_cent_K_Z_em(:,p));
end

%% Hard coding
PC_X_std(:,end) = -PC_X_std(:,end);
%%

%Calculate distance matrix
Dist = ones(N,1)*sum(PC_cent_K_Z_em.^2,2)'+sum(PC_X_std.^2,2)*ones(1,N)-2*PC_X_std*PC_cent_K_Z_em';
% Dist_part2 = 0;
% for p = 1:P
%     cord_mat = 2*PC_X_std(:,p)*PC_cent_K_Z_em(:,p)';
%     if sum(sum(cord_mat))>=0
%         Dist_part2 = Dist_part2 - cord_mat;
%     else
%         p
%         Dist_part2 = Dist_part2 + cord_mat;
%     end
% end
% 
% Dist = Dist_part1 + Dist_part2;

ind = 1:N;
%Initialize the weight matrix, W
W=zeros(N,N);
%Caluculate weight for embedding
for i = 1:N
    temp = Dist(i,:);
    for j = 1:k_neig
        [val, l] =  min(temp(j:end));
        temp_val = temp(j);
        temp_ind = ind(j);
        temp(j) = temp(l+j-1);
        ind(j) = ind(l+j-1);
        temp(l+j-1) = temp_val;
        ind(l+j-1)=temp_ind;
    end
    W(i,ind(1:k_neig))=Dist(i,ind(1:k_neig))/sum(Dist(i,ind(1:k_neig)));
end
end